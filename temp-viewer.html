<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title></title>

  <link rel="icon"          href="../favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" />
  <link href="https://fonts.googleapis.com/css?family=Raleway|Open+Sans" rel="stylesheet">
  <!-- Bootstrap css -->
  <link href="./components/bootstrap/bootstrap.min.custom-breakpoint.css" rel="stylesheet">
  <!--  leaflet css -->
  <link rel="stylesheet" href="./components/leaflet/leaflet.css" />

</head>
<body>

  <div class="container" id="header-container">
      <!-- header row -->
      <div class="row">

          <!-- title -->
          <div class="col-sm-12">
              <h2>One hundred years of temperature</h2>
          </div>

          <!-- tagline text -->
          <div class="col-sm-9">
            <p> 
              At a small number of sites, daily high and low temperatures have been continuously and reliably recorded 
              for more than one hundred years, forming one of the most longitudinally complete bodies of climate data in the world.
            </p>
          </div>

          <!-- about/links -->
          <div class="col-sm-3 zero-pad-left" id="header-links-container">
                <a href="http://kchev.org">kchev.org</a> | 
                <a href="https://github.com/keithchev/">github</a>
          </div>
      
      </div> <!-- end row -->
      <div class="row" id="tabs-container"></div>
    </div> <!-- end main container -->

  <div class="container" id="main-container">

    <div class="row">

      <div class="col-sm-12 zero-pad-left">

        <!-- left column: map -->
        <div class="col-sm-6 zero-pad-left">
          <h3 id="map-header"></h3>
          <div class="col-sm-12 zero-pad-left" id="map-text"><p></p></div>
          <div class="col-sm-12 zero-pad-left" id="map-controls-container">
            <div class="map-button-label">Color: </div>
          </div>
          <div class="col-sm-12 zero-pad-left" id="map-container"></div>
          <div class="col-sm-12 zero-pad-left" id="map-roadtrip-container"></div>
        </div>

        <!-- right column: histogram/plots -->        
        <div class="col-sm-6 zero-pad-left">
          <h3 id="histogram-header"></h3>
          <div class="col-sm-12 zero-pad-left" id="histogram-text"><p></p></div>
          <div class="col-sm-12 zero-pad-left" id="histogram-controls-container"></div>
          <div class="col-sm-12 zero-pad-left" id="histogram-title">
            <p id="histogram-title-name"></p>
            <p id="histogram-title-elevation"></p>
          </div>
          <div class="col-sm-12 zero-pad-left" id="histogram-container"></div>
        </div>

</div>


    </div>   <!-- end row -->
  </div> <!-- end container -->


  <!-- custom style -->
  <link rel="stylesheet/less" type="text/css" href="styles/temp-viewer.main.less" />

  <!-- less default options -->
  <script>
    less = {
      env: "development",
      async: false,
      fileAsync: false,
      poll: 1000,
      functions: {},
      dumpLineNumbers: "comments",
      relativeUrls: false,
      rootpath: ":/a.com/"
    };
  </script>

  <!-- third-party components -->
  <script src="./components/less/less.min.js"></script>
  <script src="./components/leaflet/leaflet.js"></script>

  <!-- d3 -->
  <script src="./components/d3.v4/d3.min.js"></script>
  <script src="./components/d3-tip/index.js"></script>
  <script src="./components/d3-scale-chromatic.v1.min.js"></script>
  <script src="./components/topojson.v1.min.js"></script>
  <script src="./components/d3-selection-multi.min.js"></script>

  <!-- load this app's global object -->
  <script src="./scripts/initGlobals.js"></script>

  <script>

  d3.csv('./data/USHCN-network-metadata.clean.crop.means.txt', function(err, stationInfoList) {
    
    stationInfoList.forEach(function (row) {
      
      row.lat = +row.lat;
      row.lon = +row.lon;
      row.mhigh = +row.mhigh;
      row.mlow = +row.mlow;
      row.alt = +row.alt * 3.28;
      row.color = "#333" // initial map dot color;

      // d3-selectable dom IDs can't begin with a number
      row.domid = "id-" + row.id;

      row.name = row.name.replace('-', ' ');

      // capitalize the first letter of each word - from http://stackoverflow.com/questions/196972/convert-string-to-title-case-with-javascript/
      row.name = row.name.replace(/\w\S*/g, function (txt) { return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase(); });
    });

    TEMPS.roadTrip.forEach(function (row) {
      row.domid = "id-" + row.id;
    });

    // list of all stations
    TEMPS.stationInfoList = stationInfoList;

    // draw the tab divs (could be hard-coded, really)
    drawTabs();

    // start at first tab, obviously - this should be 'highs/lows'
    TEMPS.currentTab = TEMPS.tabs[0];

    // initialize a current station getter/setter 
    TEMPS.currentStation = makeCurrentStation();
    TEMPS.currentRoadTripIndex = TEMPS.roadTrip.length-1;

    // *** MAP PANEL ***
    // US map with stations - this is fixed for all tabs (only station color changes)
    TEMPS.stationMap = loadStationMap();

    TEMPS.linePlot = makeLinePlot();

    // *** INITIALIZE HISTOGRAM ***
    // radial high/low temps heatmap
    TEMPS.radialHistogram = makeRadialHistogram();

    // finally, load the first tab, using first road trip stop as the initial station
    loadTab(TEMPS.roadTrip[TEMPS.currentRoadTripIndex].id);

  });


  function drawTabs() {

    var tabs = d3.select("#tabs-container").selectAll(".tab")
      .data(TEMPS.tabs).enter()
      .append("div")
      .attr("class", "col-xs-2 tab")
      .attr("id", getField("id"))
      .on("click", function (d) { 
          TEMPS.currentTab = d; 
          loadTab(null); 
      });

    tabs.append("span").attr("class", "tab-header").text(getField("header"));
    tabs.append("span").attr("class", "tab-text").text(getField("text"));
  }

  function loadTab(initialStationID) {

    d3.selectAll(".tab").classed("tab-active", false);
    d3.select("#" + TEMPS.currentTab.id).classed("tab-active", true);

    d3.select("#map-header").text(TEMPS.currentTab.mapHeader);
    d3.select("#histogram-header").text(TEMPS.currentTab.histogramHeader);

    d3.select("#map-text").select("p").text(TEMPS.currentTab.mapText);
    d3.select("#histogram-text").select("p").text(TEMPS.currentTab.histogramText);

    // update the map to the current Tab 
    // NEED TO REMOVE ROAD TRIP BUT RE-MARK CURRENT STATION
    TEMPS.stationMap[TEMPS.currentTab.method]();

    // redraw the histogram from scratch and set its .update method
    TEMPS.radialHistogram[TEMPS.currentTab.method]();

    // set the current station
    // this updates the histogram (whose .update was set above) to the current station
    // (if initialStationInfo is null, reload the existing currentStation)
    TEMPS.currentStation.set(initialStationID);

    // load high-low specific controls 
    if (TEMPS.currentTab.id==="highs-lows") {

      TEMPS.linePlot.showHover();

    }

    // load change-specific controls
    // add a button to histogram to toggle between tmin and tmax
    // add a button to the map to color by change in average high/low
    if (TEMPS.currentTab.id==="changes") {

      TEMPS.linePlot.showBrushes();


    }


    if (TEMPS.currentTab.id==="changes-regional") {

    }

  } //loadTab


  function makeCurrentStation() {
    
    var currentStationInfo = {};
    function currentStation() {}

    currentStation.set = function(stationID) {

      if (arguments.length && stationID) {
        currentStationInfo = TEMPS.stationInfoList[TEMPS.stationInfoList.map(getField('id')).indexOf(stationID)];
      }

      // mark the station on the map
      TEMPS.stationMap.markCurrentStation();

      // load the station data (and update the histogram)
      loadCurrentStationData();

      return currentStation;
    }

    currentStation.get = function () {
      return currentStationInfo;
    }

    return currentStation;
  }


  function loadStationMap() {

    var stationInfoList = TEMPS.stationInfoList,
        mapWidth  = 450,
        mapHeight = mapWidth/1.5,
        mapScale  = 600;

    var svg        = d3.select("#map-container").append("svg").attr("width", mapWidth).attr("height", mapHeight),
        projection = d3.geoAlbersUsa().translate([mapWidth/2, mapHeight/2]).scale(mapScale),
        mapPath    = d3.geoPath().projection(projection);

    var spotRadius = 3;
    var lastRoadTripIndex = 0;

    // colorbar container 
    var scaleHeight = 10,
        scaleWidth  = 100,
        colorScaleG = svg.append("g")
                         .attr("id", "map-colorbar-axis")
                         .attr("class", "axis")
                         .attr("transform", "translate(" + (25) + "," + (mapHeight-scaleHeight-30) + ")");
      
    // -----------------------------------------------------
    //
    // Colorbar buttons
    //
    // -----------------------------------------------------

    // colorbar selection buttons
    var mapButtons = {
     "map-button-elevation": { color: colorByAlt, 
                               stationInfoKey: "alt",
                               tickFunc: function (d) { return d/1000; }, 
                               tickVals: d3.range(0, 7500, 1500),
                               text: "Elevation",
                             },
     "map-button-average-low": {color: colorByAverage(18, 64),
                                stationInfoKey: "mlow",
                                tickFunc: appendDegreeSign, 
                                tickVals: d3.range(20, 70, 10),
                                text: "Average low",
                              },
     "map-button-average-high": {color: colorByAverage(49, 83), 
                                stationInfoKey: "mhigh",
                                tickFunc: appendDegreeSign, 
                                tickVals: d3.range(45, 95, 10),
                                text: "Average high", } };

    var mapButtonHandler = function (buttonID) { 
      var id = buttonID ? buttonID : this.id;
      stationMap.setColorScale(id); 
      d3.selectAll(".map-button").classed("map-button-active", false);
      d3.select("#" + id).classed("map-button-active", true);
    };

    d3.select("#map-controls-container").selectAll(".map-button").data(Object.keys(mapButtons))
      .enter().append("div")
      .attr("class", "map-button")
      .attr("id", function (d) { return d; })
      .text(function (d) { return mapButtons[d].text; })
      .on("click", mapButtonHandler);

    // -----------------------------------------------------
    //
    // Station hover tips
    //
    // -----------------------------------------------------

     // hover tip for station dots
    var stationTip = d3.tip().attr("class", "d3-tip").offset([-10,0]);
    stationTip.html(function (d) { 
          HTMLString = 
          "<span class='tip-field'>Name: </span>" + 
          "<span class='tip-value'>" + d.name + "</span><br>" + 
          "<span class='tip-field'>Elevation: </span>" + 
          "<span class='tip-value'>" + d3.format('.0f')(d.alt) + "ft</span><br>" + 
          "<span class='tip-field'>ID: </span>" + 
          "<span class='tip-value'>" + d.id + "</span><br>" + 
          "<span class='tip-field'>Average high/low: </span>" + 
          "<span class='tip-value'>" + d3.format('.0f')(d.mhigh) + "°/" + d3.format('.0f')(d.mlow) + "°</span><br>";
          return HTMLString;
    });


    // -----------------------------------------------------
    //
    // Load and draw the US map
    //
    // -----------------------------------------------------

    // load and draw states and stations
    d3.json('./data/us-states.json', function(err, us) {

      var lower48 = us.features.filter(function (f) { return f.properties.name!=='Alaska' && f.properties.name!=="Hawaii"; });

      svg.selectAll("path.map-state").data(lower48)
         .enter().append("path")
         .attr("class", "map-state")
         .attr("d", mapPath);

     // make sure dots are on top - asynchrony means states are probably drawn last
     svg.selectAll(".map-station-dots").moveToFront();
     svg.selectAll(".map-station-dots-hidden").moveToFront();

    }); // d3.json
    svg.call(stationTip);


    // -----------------------------------------------------
    //
    // Draw station dots
    //
    // -----------------------------------------------------

    // add a dot for each station
    svg.selectAll(".map-station-dots").data(stationInfoList)
       .enter().append("circle")
       .attrs({
          class: "map-station-dots",
          id: function(d) { return "id-" + d.id; },
          cx: function(d) { return projection([d.lon, d.lat])[0]; },
          cy: function(d) { return projection([d.lon, d.lat])[1]; },
          fill: getField("color"),
          r: spotRadius
        });

    // overlay hidden larger dots to capture mouseover events
    svg.selectAll(".map-station-dots-hidden").data(stationInfoList)
       .enter().append("circle")
       .attrs({
          class: "map-station-dots-hidden",
          cx: function(d) { return projection([d.lon, d.lat])[0]; },
          cy: function(d) { return projection([d.lon, d.lat])[1]; },
          r: 8,
        })
       .on("mouseover", function(d) { 
          d3.select("#" + d.domid).classed("map-station-dots-hover", true); //.moveToFront(); 
          stationTip.show(d); 
        })
       .on("mouseout", function(d) { 
          d3.select("#" + d.domid).classed("map-station-dots-hover", false);
          stationTip.hide(d);
        })
       .on("click", function(d) {  TEMPS.currentStation.set(d.id); });

    // -----------------------------------------------------
    //
    // Table of selected regions/stations
    //
    // -----------------------------------------------------

    var regionDivs = d3.select("#map-roadtrip-container").selectAll("div").data(TEMPS.regions)
               .enter().append("div")
               .attrs({class: "road-trip-region", id: getField("region")});

    regionDivs.append("div").attr("class", "road-trip-header")
              .text(getField("label"));

    regionDivs.selectAll(".road-trip-stop")
              .data( function (region) { 
                return TEMPS.roadTrip.filter(function (roadTripStop) { return region.region===roadTripStop.region; }); 
              })
              .enter().append("div")
              .attrs({class: "road-trip-stop", id: getField('domid')})
              .text(getField("text"))
              .on("click", function (d) { TEMPS.currentStation.set(d.id); });


    function stationMap() {}

    stationMap.loadTab1 = function () {

    }

    stationMap.loadTab2 = function () {
      // color station dots by warmer/colder relative to 1911 - changed when early/late range changed
    }

    stationMap.loadTab3 = function () {
      // TBD
    }

    // -----------------------------------------------------
    //
    // Change colorbar
    //
    // -----------------------------------------------------
    
    stationMap.setColorScale = function (buttonID) {

      var id = buttonID;
     
      // color station dots by elevation by updating the color field
      // necessary so dots can be recolored on mouseover/out
      // (note: because this works, .data() must not return a copy of the bound data)
      svg.selectAll(".map-station-dots")
         .data().forEach(function (d) { d.color = mapButtons[id].color(d[mapButtons[id].stationInfoKey]); });

      // here we actually update the color
      svg.selectAll(".map-station-dots").transition().attr("fill", getField("color"));

      // draw the color scale bar for elevation 
      appendColorScale(colorScaleG, scaleWidth, scaleHeight, mapButtons[id].tickVals, mapButtons[id].color, mapButtons[id].tickFunc);

      // customize the tick labels
      if (buttonID==="map-button-elevation") {    

        colorScaleG.select("text").text("Sea level");
        d3.select(colorScaleG.selectAll("text")._groups[0][1]).attr("visibility", "hidden");

        // add 'ft' to the topmost tick
        d3.select(colorScaleG.selectAll("text")._groups[0][mapButtons[id].tickVals.length-1])
          .text( function() { return d3.select(this).text() + 'kft'; });
      }
    }

    function colorByAlt(alt) {
      var maxAlt = 9000;
      return d3.interpolateRgb("#4daf4a", "#ddaa33")(d3.scaleLinear().range([.1,1]).domain([0, .5])(alt/maxAlt));
    }

    function colorByAverage(min, max) {
      return function (average) { return d3.interpolateRdBu( 1 - (average - min) / (max - min)); };
    }

    function appendColorScale(target, scaleWidth, scaleHeight, tickVals, colorFunction, tickFunction) {

      // this makes the 1d color scale for the map
      var barScale    = d3.scaleLinear()
                          .domain([d3.min(tickVals), d3.max(tickVals)]).range([0, scaleWidth]),
           barAxis    = d3.axisBottom(barScale).tickValues(tickVals).tickSize(0,0).tickFormat(tickFunction),
           rectHeight = Math.abs(barScale(tickVals[0]) - barScale(tickVals[1]));

      target.call(barAxis);

      target.selectAll("path").attr("visibility", "hidden");
     
      var rects = target.selectAll("rect").data(tickVals);

      rects.enter().append("rect")
        .attrs({
          class: "map-colorbar-rect",
          y: -scaleHeight,
          width: rectHeight, 
          height: scaleHeight,
        })
        .merge(rects).transition()
        .attrs({
          x: function(tickVal) { return barScale(tickVal) - rectHeight/2; },
          fill: function(tickVal) { return colorFunction(tickVal); }
        })
    }


    // -----------------------------------------------------
    //
    // Mark the current station
    //
    // -----------------------------------------------------
    
    stationMap.markCurrentStation = function () {

      svg.selectAll(".map-station-dots")
         .classed("map-station-dots-selected", false)
         .filter(function (d) { return d3.select(this).attr("id")===TEMPS.currentStation.get().domid; })
         .classed("map-station-dots-selected", true)
         .moveToFront();

      d3.selectAll(".road-trip-stop")
        .classed("road-trip-stop-selected", false)
        .filter(function (d) { return d3.select(this).attr("id")===TEMPS.currentStation.get().domid; })
        .classed("road-trip-stop-selected", true);

    } // markCurrentStation


    // set the initial colorscale to elevation
    mapButtonHandler("map-button-elevation");
    return stationMap;

  } // loadStationMap


  // -----------------------------------------------------
  //
  // Load station data and update histogram
  //
  // -----------------------------------------------------
  function loadCurrentStationData() {

    var stationID = TEMPS.currentStation.get().id;

    var msPerDay = 1000*60*60*24;

    // station CSV filenames lack leading zeros
    if (stationID[0]==='0') stationID = stationID.slice(1); 

    var stationFilename = './data/stations/station_' + stationID + '.csv';

    d3.csv(stationFilename, function(err, data) {

      data.forEach(function (row) {
        row.year = +row.year;
        row.doy  = +row.doy;
        row.tmin = +row.tmin;
        row.tmax = +row.tmax;
        // calculate the date from the year and doy
        row.date = new Date("1/1/" + (row.year + 1911));
        row.date.setTime(row.date.getTime() + row.doy * msPerDay)
      });


      TEMPS.data = data.filter(function (d, i) { return d.tmin!=0 && d.tmax!=0; });

      TEMPS.data7 = TEMPS.data.filter(function (d, i) { return !(i % 7); });

      TEMPS.data7.forEach(function (d, i) {
        if (i > 1 && i < TEMPS.data7.length-1) {
          d.tmin = d3.mean(TEMPS.data7.slice(i - 2, i + 3), getField("tmin"));
          d.tmax = d3.mean(TEMPS.data7.slice(i - 2, i + 3), getField("tmax"));
        }
      });
      TEMPS.data28 = TEMPS.data7.filter(function (d, i) { return !(i % 4); });

      TEMPS.linePlot.data(TEMPS.data28).update();
      TEMPS.radialHistogram.data(TEMPS.data).update();
    });
  }


  function makeLinePlot() {

    var data;
    var width    = 450;
    var height   = 100;
    var pad = 10;
    var svg  = d3.select("#histogram-controls-container").append("svg").attrs({width: width, height: height});

    var tDomain = [new Date("1/1/1911"), new Date("12/31/2010")],
        yDomain = [-40, 100],
        yTickVals = [-30, 0, 32, 60, 90];

    var tScale = d3.scaleTime().range([pad, width-2*pad]).domain(tDomain);
    var yScale = d3.scaleLinear().range([pad, height-2*pad]).domain([yDomain[1], yDomain[0]]);

    var svgG = svg.append("g").attr("transform", "translate(" + pad + "," + pad + ")");

    var tAxis = svgG.append("g")
                    .attrs({class: "line-plot-axis", id: "t-axis", transform: "translate(" + 0 + "," + (height - 2*pad - 5) + ")"});

    var yAxis = svgG.append("g")
                    .attrs({class: "line-plot-axis", id: "y-axis", transform: "translate(" + pad + "," + 0 + ")"});

    var lineMin = d3.line().x(function (d) { return tScale(d.date); }).y(function (d) { return yScale(d.tmin); });
    var lineMax = d3.line().x(function (d) { return tScale(d.date); }).y(function (d) { return yScale(d.tmax); });
    var lineMean = d3.line().x(function (d) { return tScale(d.date); }).y(function (d) { return yScale(d.mean); });
    var mouseLine = d3.line().x(getField("x")).y(getField("y"));

    svgG.append("path").attrs({class: "line-plot-path color-tmin", id: "line-plot-path-tmin"});
    svgG.append("path").attrs({class: "line-plot-path color-tmax", id: "line-plot-path-tmax"});
    svgG.append("path").attrs({class: "line-plot-path", id: "line-plot-mouse-path"});

    tAxis.call(d3.axisBottom(tScale).tickSize(0,0));
    yAxis.call(d3.axisLeft(yScale).tickSize(-width + pad, 0).tickValues(yTickVals).tickFormat(appendDegreeSign));

    function linePlot() {}

    linePlot.update = function () {

      d3.select("#line-plot-path-tmin").transition().attr("d", lineMin(data));
      d3.select("#line-plot-path-tmax").transition().attr("d", lineMax(data));
    }

    linePlot.showHover = function () {
  
      svgG.selectAll(".brush-container").remove();

      svgG.select("#line-plot-mouse-path").attr("visibility", "visible");
      svg.on("mousemove", mousemove);

      function mousemove() {

        var mouseX = d3.mouse(svg.node())[0] - pad;
        var mouseLineData = [{x: mouseX, y: yScale.range()[0]}, {x: mouseX, y: yScale.range()[1]}];
        d3.select("#line-plot-mouse-path").attr("d", mouseLine(mouseLineData));

        TEMPS.radialHistogram.drawLine(tScale.invert(mouseX).getUTCFullYear());
      }
    }

    linePlot.showBrushes = function () {

      svgG.selectAll(".brush-container").remove();
      svgG.select("#mouse-position-path").attr("visibility", "hidden");
      svg.on("mousemove", null);

      var brushEarly = d3.brushX().extent([[pad, 0], [width-2*pad, height-2*pad-5]]).on("brush start end", brushed);
      var brushLate  = d3.brushX().extent([[pad, 0], [width-2*pad, height-2*pad-5]]).on("brush start end", brushed);

      svgG.append("g")
         .attr("class", "brush-container")
         .attr("id", "brush-early").call(brushEarly);

      svgG.append("g")
          .attr("class", "brush-container")
          .attr("id", "brush-late").call(brushLate);

      brushEarly.move(d3.select("#brush-early"), [new Date("1/1/1911"), new Date("1/1/1940")].map(tScale)); 
      brushLate.move(d3.select("#brush-late"), [new Date("1/1/1980"), new Date("1/1/2010")].map(tScale)); 

      // allows cursor to access both brushes, but prevents re-brushing in a new region
      d3.selectAll(".overlay").style("pointer-events", "none");

      function brushed() {

        var earlyRange = d3.brushSelection(d3.select("#brush-early").node());
        var lateRange  = d3.brushSelection(d3.select("#brush-late").node());

        earlyRange = earlyRange!==null ? earlyRange.map(tScale.invert) : null;
        lateRange = lateRange!==null ? lateRange.map(tScale.invert) : null;

        // careful - this won't work if data hasn't loaded yet 
        if (earlyRange!==null && lateRange!==null){
          TEMPS.radialHistogram.earlyRange(earlyRange).lateRange(lateRange).update();
        }
      }

    } // showBrushes

    linePlot.data = function (_) {
      if (!arguments.length) { return data; }
      data = _;
      return linePlot;
    }

    return linePlot;
  } // makeLinePlot


  function makeRadialHistogram() {

    var PI = Math.PI;
    var padL = 25, padR = 5, padT = 15, padB = 15;

    var minRadius   = 30,
        maxRadius   = 160,
        legendWidth = 75,
        svgHeight   = maxRadius * 2 + padT + padB, 
        svgWidth    = svgHeight + legendWidth + padL + padR;
       
    // variables with setter/getter methods
    var target, data, binData, binShape, tempRange, earlyRange = [0,30], lateRange = [70,100];

    // -----------------------------------------------------
    //
    // Histogram containers
    //
    // -----------------------------------------------------

    var svg    = d3.select("#histogram-container").append("svg").attrs({width: svgWidth, height: svgHeight}),
        svgG   = svg.append("g").attr("transform", "translate(" + padL + "," + padT + ")"),
        origin = svgG.append("g").attr("transform", "translate(" + ( maxRadius) + "," + ( maxRadius) + ")"),
        arcs   = origin.append("g"),
        axes   = origin.append("g"),
        tminPath = origin.append("path").attrs({class: "histogram-path", id: "histogram-path-tmin"});
        tmaxPath = origin.append("path").attrs({class: "histogram-path", id: "histogram-path-tmax"});

    var rScale  = d3.scaleLinear().range([minRadius, maxRadius]),
        thScale = d3.scaleLinear().range([0, 2*Math.PI]).domain([1,365]),
        tmLine = function (tm) { 
                      return d3.line()
                      .x(function (d) { return rScale(d[tm])*Math.sin(thScale(d.doy)); })
                      .y(function (d) { return -rScale(d[tm])*Math.cos(thScale(d.doy)); }); };

    // -----------------------------------------------------
    //
    // Histogram heatmap legend
    //
    // -----------------------------------------------------

    var legendPad = 50,
        legendTickVals = d3.range(0,1,.1),
        legendXScale   = d3.scaleLinear().range([0, legendWidth]).domain([0, d3.max(legendTickVals)]),
        legendYScale   = d3.scaleLinear().range([legendWidth, 0]).domain([0, d3.max(legendTickVals)]),
        rectSize       = legendXScale(legendTickVals[1]) - legendXScale(legendTickVals[0]),

        legendG = svgG.append("g")
                      .attr("id", "histogram-legend")
                      .attr("transform", "translate(" + (svgWidth - legendWidth - legendPad) + "," + (0 + 0*(svgHeight - legendWidth - legendPad + 15)) + ")");


    //re-draws the radial histogram axes for given rTickValues
    function drawAxes (tempRange, rTickValues) {

      axes.selectAll("circle").remove();
      axes.selectAll("text").remove();
      axes.selectAll("path").remove();

      rScale.domain(tempRange);

      // add radial (temperature) ticks
      axes.selectAll("radius-axis.histogram-line")
            .data(rTickValues)
            .enter().append("circle")
            .attr("class", "radius-axis histogram-line")
            .attr("r", function (d) { return rScale(d +2.5); });

      axes.selectAll(".radius-axis.histogram-text")
            .data(rTickValues)
            .enter().append("text")
            .attr("class", "radius-axis histogram-text")
            .attr("x", function (d) { return -rScale(d + 0) * Math.cos(PI/4); })
            .attr("y", function (d) { return -rScale(d + 0) * Math.sin(PI/4); })
            .text(appendDegreeSign);

      
      var thTickStop   = rScale(d3.max(rTickValues)) + 2;
      var thTickStart  = rScale(d3.min(rTickValues)) + 2;
      var thTickLine   = [{x: thTickStart, y:0}, {x: thTickStop, y:0}];

      var thTickValues = [ {theta: 0, label: 'April', labelX: thTickStop + 14, labelY: 2},
                           {theta: 90, label: 'June', labelX: 0, labelY: thTickStop + 10},
                           {theta: 180, label: 'Sep', labelX: -thTickStop - 12, labelY: 2},
                           {theta: -90, label: 'January', labelX: 0, labelY: -thTickStop - 4} ];

      // add angle (month) ticks
      axes.selectAll(".th-axis.histogram-line")
            .data(thTickValues)
            .enter().append("path")
            .attr("class", "th-axis histogram-line")
            .attr("d", function (tick) { return d3.line().x(getField('x')).y(getField('y'))(thTickLine); })
            .attr("transform", function (tick) { return "rotate(" + tick.theta + ",0, 0)"; });

      axes.selectAll(".th-axis.histogram-text")
            .data(thTickValues)
            .enter().append("text")
            .attr("class", "th-axis histogram-text")
            .attr("x", getField('labelX'))
            .attr("y", getField('labelY'))
            .text(getField('label'));
    }

    function radialHistogram() {}

    radialHistogram.loadTab1 = function () {
      tempRange    = [-20, 110];
      rTickValues  = [0, 32, 60, 90, 110];
      calcBinColor = calcHighLowBinColor;
      binShape     = {daysPerBin: 5, tempPerBin: 5}; // bin size

      // update function for drawing highs/lows
      radialHistogram.update = drawHighsLows;
      resetHistogram();

      drawLegend(calcBinColor, "Frequency of highs", "Frequency of lows");
    }

    radialHistogram.loadTab2 = function () {
      tempRange    = [0, 70];
      rTickValues  = [30, 60];
      calcBinColor = calcEarlyLateBinColor;
      binShape     = {daysPerBin: 10, tempPerBin: 5}; // bin size

      // update function for drawing early/late
      radialHistogram.update = drawEarlyLate;
      resetHistogram();

      drawLegend(calcBinColor, "More frequent now", "More frequent then");
    }

    function resetHistogram() {

      // remove existing bins since bin size/number is going to change
      arcs.selectAll(".histogram-bin").remove();

      // draw the axes
      drawAxes(tempRange, rTickValues);
    }

    function drawLegend(calcBinColor, text1, text2) {

      var legendData = [];
      legendTickVals.map(function (tickX) {
        legendTickVals.map(function (tickY) {
          legendData.push( {x: legendXScale(tickX), y: legendYScale(tickY), color: calcBinColor(tickX, tickY) });
        });
      });

      var legend = legendG.selectAll("rect").data(legendData);

      legend.enter().append("rect")
            .merge(legend).transition()
            .attrs({
              class: "histogram-legend-rect",
              x: getField("x"),
              y: getField("y"),
              width: rectSize, height: rectSize,
              fill: getField("color"),
            });

      legendG.selectAll("text").remove();
            
      legendG.append("text")
            .attrs({x: -legendWidth/2 - rectSize/2, y: -3, transform: "rotate(-90)"})
            .text(text1);

      legendG.append("text")
            .attrs({x: legendWidth/2 + rectSize/2, y: legendWidth + rectSize + 8})
            .text(text2);
    }

    function drawHighsLows() {

      if (data===undefined) return;

      // generate bin data for current station data (assume binShape unchanged) 
      binData = calcHighLowHistogram(data, binShape, tempRange);

      // assign colors: modifies bindata.binlist in place
      assignColorsToBins(binData.binList, 'tminCount', 'tmaxCount', calcBinColor);

      drawBins(binData);

      return;
    }

    function drawEarlyLate() {

      if (data===undefined) return;

      binData = calcEarlyLateHistogram(data, binShape, tempRange, earlyRange, lateRange);
      assignColorsToBins(binData.binList, 'tminCountEarly', 'tminCountLate', calcBinColor);

      drawBins(binData);

      return;
    }

    function drawBins(binData) {

      var bins = arcs.selectAll(".histogram-bin").data(binData.binList);

      bins.enter().append("path")
          .attr("class", "histogram-bin")
          .attr("d", makeArc)
        .merge(bins).transition().duration(500)
          .attr("fill", function (bin) { return bin.color; })
          .style("opacity", function (bin) { return bin.opacity; })

      bins.exit().remove();

      axes.selectAll(".histogram-line").moveToFront();
      axes.selectAll(".histogram-text").moveToFront();

      d3.select("#histogram-title-name").text(TEMPS.currentStation.get().name + ", " + TEMPS.currentStation.get().state);
      d3.select("#histogram-title-elevation").text("Elevation: " + d3.format(".0f")(TEMPS.currentStation.get().alt) + " feet");

      function makeArc(bin) {
        var arc = d3.arc()
                    .innerRadius(rScale(bin.tmp))
                    .outerRadius(rScale(bin.tmp + binShape.tempPerBin))
                    .startAngle(thScale(bin.doy))
                    .endAngle(thScale(bin.doy + binShape.daysPerBin ));

        return arc();
      }
    }

    radialHistogram.drawLine = function (year) {
      // method called by lineplot's mouseover function
      // draw a line plot of temperatures from the mouse position's year over the histogram

      var iYear = year - 1911 - 1,
          fYear = year - 1911;

      var lineData = data.filter(function (d) { return d.year >= iYear && d.year < fYear });

      tminPath.transition().attr("d", tmLine("tmin")(lineData));
      tmaxPath.transition().attr("d", tmLine("tmax")(lineData));

    }


    radialHistogram.target = function(_) {
      if (!arguments.length) { return target; }
      target = _;
      return radialHistogram;
    }

    radialHistogram.data = function(_) {
      if (!arguments.length) { return data; }
      data = _;
      return radialHistogram;
    }

    radialHistogram.binShape = function(_) {
      if (!arguments.length) { return binShape; }
      binShape = _;
      return radialHistogram;
    }

    // early range and late range are only used by the earlyLate histogram
    radialHistogram.earlyRange = function(_) {
      if (!arguments.length || !_) { return earlyRange; }
      earlyRange = _.map(function (d) { return d.getUTCFullYear() - 1911; });
      return radialHistogram;
    }

    radialHistogram.lateRange = function(_) {
      if (!arguments.length || !_) { return lateRange; }
      lateRange = _.map(function (d) { return d.getUTCFullYear() - 1911; });
      return radialHistogram;
    }

    return radialHistogram;
  } // makeRadialHistogram


  function calcEarlyLateHistogram(data, binShape, tempRange, earlyRange, lateRange) {

    dataEarly = data.filter(function (d) {
      return (d.year > earlyRange[0] && d.year <= earlyRange[1]);
    });

    dataLate = data.filter(function (d) {
      return (d.year > lateRange[0] && d.year <= lateRange[1]);
    });

    binDataEarly = calcHighLowHistogram(dataEarly, binShape, tempRange);
    binDataLate  = calcHighLowHistogram(dataLate, binShape, tempRange);

    binDataMerge = {};
    binDataMerge.tmpBins = binDataEarly.tmpBins;
    binDataMerge.dayBins = binDataEarly.dayBins;

    binList = [];

    binDataEarly.binList.forEach(function (bin, ind){

      var bin_ = {};

      bin_.doy = bin.doy;
      bin_.tmp = bin.tmp;

      bin_.tmaxCountEarly = binDataEarly.binList[ind].tmaxCount;
      bin_.tminCountEarly = binDataEarly.binList[ind].tminCount;
      bin_.tmaxCountLate  = binDataLate.binList[ind].tmaxCount;
      bin_.tminCountLate  = binDataLate.binList[ind].tminCount;

      binList.push(bin_);

    });

    binDataMerge.binList = binList;

    return binDataMerge;
  }

  function calcHighLowHistogram(data, binShape, tempRange) {

    var tmpBins = d3.range(tempRange[0], tempRange[1] + binShape.tempPerBin, binShape.tempPerBin);
    var dayBins = d3.range(0, 365, binShape.daysPerBin);

    //domain must be specified along with thresholds
    var calcHistogram = d3.histogram().domain(tempRange).thresholds(tmpBins);

    var hArray = dayBins.map(function(binEdge) {
            
            var data_ = data.filter(function(d) { 
              return d.doy > binEdge && d.doy <= (binEdge + binShape.daysPerBin); 
            });

            return {
                    counts: d3.zip(
                      calcHistogram(data_.map(getField('tmin'))).map(getField('length')),
                      calcHistogram(data_.map(getField('tmax'))).map(getField('length')) ),
                    doy: binEdge,
                  };
    });

    binList = [];

    // list of counts at each day bin
    hArray.map(function(dayRow, i) {

      // count for each temperature bin
      dayRow.counts.map(function(count, j) {

        // add the histogram bin to the list if there's some nonzero temps
        if (true) { //(count[0] || count[1]) {
          binList.push({tminCount: count[0], tmaxCount: count[1], doy: dayBins[i], tmp: tmpBins[j] });
        }

      });
    });

    return {binList: binList, tmpBins: tmpBins, dayBins: dayBins};
  }

  function assignColorsToBins(binList, countName1, countName2, binColorFunction) {

    var thresh = 0; //15;

    var count1Max = d3.max(binList, getField(countName1)) - thresh,
        count2Max = d3.max(binList, getField(countName2)) - thresh,
        count1, count2,
        count1Color, count2Color;

    binList.forEach(function (bin) {

      count1 = bin[countName1] > thresh ? bin[countName1] - thresh : 0;
      count2 = bin[countName2] > thresh ? bin[countName2] - thresh : 0;

      bin.color = "#ffffff";
      bin.opacity = .5;

      if (count1 || count2) {
        bin.color = binColorFunction(count1/count1Max, count2/count2Max);
        bin.opacity = 1;
      }

    });
  }

  function calcHighLowBinColor(density1, density2) {

        var color1 = d3.interpolateBlues(density1);
        var color2  = d3.interpolateReds(density2);

        return d3.interpolateLab(color1, color2)(.5);
  }

  function calcEarlyLateBinColor(density1, density2) {

        // this function is 1 when densities are nearly equal; zero elsewhere
        var dd = Math.exp( -900*(1-Math.exp((density1 - density2)**2))**2 );

        var color1 = d3.interpolateYlOrBr(density1);
        var color2 = d3.interpolateYlGn(density2);

        var color12 = density1 > density2 ? color1 : color2;
        
        color12Gray = d3.hsl(d3.color(color12));
        color12Gray.s = 0;

        return d3.interpolateLab(color12, color12Gray)(dd);
  }



  function appendDegreeSign (d) { return d + '°'; }
  function getField(key) { return function(d) { return d[key]; } }

  Date.prototype.getWeek = function() {
      var janFirstThis = new Date(this.getFullYear(),0,1);
      return Math.ceil((((this - janFirstThis) / 86400000) + janFirstThis.getDay()+1)/7);
  } 

  Array.prototype.last = function(){
      return this[this.length - 1];
  };

  Array.prototype.copy = function(){
      return this.slice(0);
  }

  Array.prototype.unique = function() {
    var elementsAsKeys = {},
        uniqueElements = [];
    for (var i = 0; i < this.length; ++i) {
        if (!elementsAsKeys.hasOwnProperty(this[i])) {
            uniqueElements.push(this[i]);
            elementsAsKeys[this[i]] = 1; // arbitrary value
        }
    }
    return uniqueElements;
}

  // ** copied from MBTA viz **
  // add utility to move an SVG selection to the front
  d3.selection.prototype.moveToFront = function () {
    return this.each(function () {
      this.parentNode.appendChild(this);
    });
  };



  </script>

</body>
</html>
